<link rel="import" href="../polymer/polymer-element.html">
<link rel="import" href="../vaadin-grid/vaadin-grid-column.html">
<link rel="import" href="px-data-grid-header-cell.html">

<dom-module id="px-data-grid-easy-column">
  <template>
    <template class="header" id="defaultHeaderTemplate">
        <vaadin-grid-sorter path="[[sortPath]]">[[name]]</vaadin-grid-sorter>
    </template>
    <template id="defaultBodyTemplate">
      <div class="" style$="[[_getCellStyle(item, column)]]">
        [[_resolveValue(item)]]
      </div>
    </template>
  </template>
  <script>
    {
      /**
       * A `<px-data-grid-column>` is used to configure how a column in `<px-data-grid>`
       * should look like by using HTML templates.
       * A column can have a template for each of the three table sections: header, body and footer.
       *
       * The `class` attribute is used to differentiate header and footer templates from the body template.
       *
       * #### Example:
       * ```html
       * <px-data-grid-column>
       *   <template class="header">I'm in the header</template>
       *   <template>I'm in the body</template>
       *   <template class="footer">I'm in the footer</template>
       * </px-data-grid-column>
       * ```
       *
       * @memberof Predix
       * @extends Vaadin.GridColumnElement
       */
      class DataGridEasyColumnElement extends Vaadin.GridColumnElement {
        static get is() {
          return 'px-data-grid-easy-column';
        }

        static get properties() {
          return {

            /**
             * Name of column is used on table action menu to offer hide/show functionality. As headers are fully optional
             * and might not even contain the name of column, this separate value is required if you use table action menu.
             */
            name: {
              type: String
            },

            sortPath: {
              type: String
            },

            provider: {
              type: Function,
              value: function(i) {
                return undefined;
              }
            },

            resources: {
              type: Object
            },

            _headerCellContentWrapper: {
              type: Element
            },

            /**
             * Type of the column. Can be string, number or date.
             */
            type: {
              type: String,
              value: 'string',
              observer: '_typeChanged'
            },

            _permittedTypes: {
              type: Array,
              value: ['string', 'number', 'date']
            }
          };
        }

        static get observers() {
          return [
            '_updateI18n(language, resources, _headerCellContentWrapper)'
          ];
        }

        _stampHeaderTemplate(headerTemplate, headerCell) {
          if (!headerTemplate || !headerCell || headerCell._instance) {
            return;
          }

          const inst = headerTemplate.templatizer.createInstance();

          const headerCellContentWrapper = document.createElement('px-data-grid-header-cell');
          headerCellContentWrapper.appendChild(inst.root);
          headerCellContentWrapper._column = this;

          headerCell._content.appendChild(headerCellContentWrapper);
          headerCell._instance = inst;
          headerCell.parentElement.hidden = false;

          this._headerCellContentWrapper = headerCellContentWrapper;
        }

        _prepareHeaderTemplate() {
          const headerTemplate = this._prepareTemplatizer(this._findTemplate('template.header') || this.$.defaultHeaderTemplate);
          // needed to override the dataHost correctly in case internal template is used.
          headerTemplate.templatizer.dataHost = headerTemplate === this.$.defaultHeaderTemplate ? this : this.dataHost;
          return headerTemplate;
        }

        _prepareBodyTemplate() {
          const template = this._prepareTemplatizer(this._findTemplate('template:not(.header):not(.footer)') || this.$.defaultBodyTemplate);
          // needed to override the dataHost correctly in case internal template is used.
          template.templatizer.dataHost = template === this.$.defaultBodyTemplate ? this : this.dataHost;
          return template;
        }

        _updateI18n(language, resources, _headerCellContentWrapper) {
          if (!_headerCellContentWrapper) {
            return;
          }

          _headerCellContentWrapper.language = language;
          _headerCellContentWrapper.resources = resources;
        }

        _typeChanged(type) {
          if (type && this._permittedTypes.indexOf(type.toLowerCase()) == -1) {
            console.warn(`${type} is unsupported type for px-data-grid-easy-column.`);
          }
        }

        _getCellStyle(item, column) {
          return this._grid._getCellStyle(item, column);
        }

        _resolveValue(item) {
          console.log(this.provider);
          return this.provider(item);
        }
      }

      customElements.define(DataGridEasyColumnElement.is, DataGridEasyColumnElement);

      /**
       * @namespace Predix
       */
      window.Predix = window.Predix || {};
      Predix.DataGridEasyColumnElement = DataGridEasyColumnElement;
    }
  </script>
</dom-module>
